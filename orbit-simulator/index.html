<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
  canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
  }
</style>
</head>
<body onload="startSim()">
  <script>
  var accel = 10; // The acceleration towards the black dot.
  var pointOfAccel, orbiter, sling; // The variables for the black dot, red ball, and the line.
  var mousedown = false; // Is the mouse down?
  var startx = 0, starty = 0; // Where the mouse is pressed down.

  function startSim() { // start the sim.
    simArea.start(); // initalise the canvas.

    // initalise the objects.
    pointOfAccel = new circle(2, "black", simArea.canvas.width/2, simArea.canvas.height/2, 0, 0); // The black dot.
    orbiter = new circle(5, "red", simArea.canvas.width/2, 20, 30, 0); // the red ball.
    sling = new line("red",0,0); // the line when you drag.
  }

  var simArea = { // the canvas!
    canvas : document.createElement("canvas"), // create a canvas.
    start : function() { // initalise
      // width and hight of window.
      this.canvas.width = 480;
      this.canvas.height = 270;
      // get the 2d context. That suggests there's a 3d one, wouldn't that be cool!
      this.context = this.canvas.getContext("2d");
      document.body.insertBefore(this.canvas, document.body.childNodes[0]); // place the simulator at the top of the page.
      this.interval = setInterval(updateSimArea, 20); // call the updateSimArea function every 20ms.

      // listen for mouse being pressed.
      window.addEventListener('mousedown', function (e) {
        // when pressed set the start x and y, and flip the boolean.
        startx = e.pageX;
        starty = e.pageY;
        mousedown = true;
      });
      // listen for the mouse being released.
      window.addEventListener('mouseup', function (e){
        // set finish x and y.
        var finishx = e.pageX;
        var finishy = e.pageY;

        // set the orbiter's velocity to the difference between the start point and the end point.
        orbiter.velX = startx-finishx;
        orbiter.velY = starty-finishy;

        // flip dat flag.
        mousedown = false;

      });
      // when the mouse moves, update the sling line start/end.
      window.addEventListener('mousemove', function (e){
        sling.x = e.pageX;
        sling.y = e.pageY;
      });
    },

    clear : function() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // clears the screen.
    }
  }

  // draws a line from the center of the orbiter (red ball) to the mouse pointer.
  function line(color, x, y){
    // set the inital x and y. color for now is redundant.
    this.x = x;
    this.y = y;
    // when this is called draw the line to the context. I would really prefer this to be called draw.
    this.update = function(){
      ctx = simArea.context; // the context to draw to.
      ctx.beginPath(); // begin drawing path.
      ctx.moveTo(startx,starty); // move to startx, starty.
      ctx.lineTo(this.x,this.y); // draw a line to x,y;
      ctx.stroke(); // actually draw it.
    }
  }
  // draw a circle object.
  function circle(radius, color, x, y, velX, velY) {
    this.radius = radius;
    this.x = x;
    this.y = y;
    this.velX = velX;
    this.velY = velY;
    // call this to draw it.
    this.update = function(){

      ctx = simArea.context;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI); // draw an arc of 2pi radians or 360 degrees, aka a circle.
      ctx.stroke(); // actually draw it.
      ctx.fillStyle = color; // the fill color.
      ctx.fill(); // grab crayons and color it in.
    }
  }

  // the update function called every 20ms.
  function updateSimArea() {
    simArea.clear(); // clear the screen.
    pointOfAccel.update(); // draw the black dot.

    var time = 0.02; // a reference to 20ms.

    if(mousedown){
      // if the mouse is down, draw the sling, and keep the orbiter stationary
      sling.update();
      orbiter.x = startx;
      orbiter.y = starty;
    }else{
      // if the mouse is not down, then calculate where the orbiter moves to and what it's next velocity is.

      // add the distance traveled to the orbiter.
      orbiter.x += orbiter.velX*time;
      orbiter.y += orbiter.velY*time;

      //calculate the angle between the orbiter and the point of acceleration.
      // Maths.atan is arctan, it's the inverse of tan. Basic trig.
      // Maths.abs is absolute, absolute removes minus signs, abs(-20) = 20; abs(20) = 20;
      var accelAngle = Math.atan(Math.abs(pointOfAccel.y-orbiter.y)/Math.abs(pointOfAccel.x - orbiter.x));

      // calculate the undirectional acceleration of the orbiter in the x and y.
      // Math.cos and Math.sin are cosine and sine respectively, again basic trigonometry.
      var accelX = accel*Math.cos(accelAngle);
      var accelY = accel*Math.sin(accelAngle);

      // give the acceleration direction with som boolean math. The answer of the maths, can be either -1 or 1. I'm just putting
      // back the minus abs removed.
      accelX *= -1 + 2*(0<=(pointOfAccel.x-orbiter.x));
      accelY *= -1 + 2*(0<=(pointOfAccel.y-orbiter.y));

      // v = u + at.
      orbiter.velX += accelX*time;
      orbiter.velY += accelY*time;
    }
    orbiter.update(); // draw the orbiter.
  }
</script>
<h1>Basic Orbit Simulator</h1>
<p>Give it a go! Click and drag to fire the red ball into orbit around the dot!</p>
<p> This simulator, shows how if an object accelerates towards a fixed point, it can be placed in an 'orbit' provided it is given a bit of velocity perpendicular to the direction of acceleration. This still works when the point becomes a circle or a sphere, provided the object is given enough force, it will perpetually fall around the source of acceleration. </p>
<p>The only equations used in this are; ,<b>v = u + at</b>, a fundemental equation of motion, <b>s = vt</b>, the distance travelled in a set amount of time, and some basic trigonometry to break the velocity and acceleration into their respective x and y components.</p>
<p>You can check the source code and see that there is nothing shady going on by either, right clicking and selecting "view source" or visiting the github source via this link: <a href="https://github.com/Kranex/kranex.github.io/blob/master/orbit-simulator/index.html">https://github.com/Kranex/kranex.github.io/blob/master/orbit-simulator/index.html</a></p>
</body>
</html>
